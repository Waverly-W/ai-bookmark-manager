# 级联面板组件说明

## 设计目标

重新设计书签文件夹选择组件，实现级联面板（Cascading Panel）交互模式，提供类似于 macOS Finder 列视图的直观文件夹导航体验。

## 交互逻辑设计

### 🎯 **核心交互模式**

#### 1. **初始状态**
- 显示第一层级的所有文件夹列表
- 触发器显示当前选中的文件夹
- 点击触发器展开级联面板

#### 2. **悬停/点击展开**
- **悬停展开**: 鼠标悬停在有子文件夹的文件夹上时，右侧展开新面板
- **延时机制**: 鼠标离开后150ms延时关闭，避免误操作
- **智能判断**: 只有包含子文件夹的文件夹才会展开新面板

#### 3. **选中逻辑**
- 点击任意文件夹即可选中（无论是否有子文件夹）
- 选中后自动关闭面板
- 触发器更新显示选中的文件夹

#### 4. **多级展开**
- 可以持续向右展开多个面板
- 形成面包屑式的层级导航
- 最多显示5个面板，避免界面过宽

#### 5. **面板联动**
- 在某一层级选择不同文件夹时，右侧的所有子面板更新
- 悬停路径变化时，动态构建面板结构

## 视觉效果设计

### 🎨 **macOS Finder 风格**

#### 级联面板布局
```
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 📁 All      │ 📁 Common   │ 📁 Tuhu     │ 📁 Project  │
│ 📁 书签栏 ✓ │ 📁 Dev      │ 📁 Wiki     │ 📁 Docs     │
│ 📁 其他书签  │ 📁 Tools    │ 📁 Test     │ 📁 Assets   │
│             │             │             │             │
└─────────────┴─────────────┴─────────────┴─────────────┘
  第一层级      第二层级      第三层级      第四层级
```

#### 触发器样式
```
收起状态:
┌─────────────────────────────────────────────┐
│ 📁 书签栏                               ▼ │
└─────────────────────────────────────────────┘

展开状态:
┌─────────────────────────────────────────────┐
│ 📁 书签栏                               ▲ │
└─────────────────────────────────────────────┘
┌─────────────┬─────────────┬─────────────┐
│ 📁 All      │ 📁 Common   │ 📁 Tuhu     │
│ 📁 书签栏 ✓ │ 📁 Dev      │ 📁 Wiki     │
│ 📁 其他书签  │ 📁 Tools    │ 📁 Test     │
└─────────────┴─────────────┴─────────────┘
```

## 技术实现

### 🔧 **CascadingFolderSelect组件**

#### 1. **核心数据结构**
```typescript
interface Panel {
    level: number;           // 面板层级
    folders: BookmarkFolder[]; // 该层级的文件夹列表
    parentId?: string;       // 父文件夹ID
}

interface CascadingFolderSelectProps {
    folders: BookmarkFolder[];
    selectedId: string;
    onSelect: (folderId: string) => void;
    className?: string;
    placeholder?: string;
}
```

#### 2. **状态管理**
```typescript
const [isOpen, setIsOpen] = useState(false);           // 面板开关状态
const [hoveredPath, setHoveredPath] = useState<string[]>([]); // 悬停路径
const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);  // 延时控制
```

#### 3. **面板构建算法**
```typescript
const panels = useMemo(() => {
    const result: Panel[] = [];
    let currentFolders = folders;
    let level = 0;

    // 第一层面板
    result.push({
        level: 0,
        folders: currentFolders,
        parentId: undefined
    });

    // 根据悬停路径构建后续面板
    for (const folderId of hoveredPath) {
        const folder = findFolderById(currentFolders, folderId);
        if (folder && folder.children && folder.children.length > 0) {
            level++;
            result.push({
                level,
                folders: folder.children,
                parentId: folderId
            });
            currentFolders = folder.children;
        } else {
            break;
        }
    }

    return result;
}, [folders, hoveredPath]);
```

#### 4. **悬停处理机制**
```typescript
const handleFolderHover = useCallback((folderId: string | null, level: number) => {
    // 清除之前的延时
    if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
    }

    if (folderId === null) {
        // 鼠标离开，延时清除悬停状态
        hoverTimeoutRef.current = setTimeout(() => {
            setHoveredPath([]);
        }, 150);
    } else {
        // 鼠标进入，立即更新悬停路径
        const newPath = hoveredPath.slice(0, level);
        newPath.push(folderId);
        setHoveredPath(newPath);
    }
}, [hoveredPath]);
```

### 🎨 **样式设计**

#### 1. **触发器样式**
```typescript
<div className={cn(
    "flex items-center justify-between gap-2 px-3 py-2 text-sm",
    "border border-input rounded-md bg-background cursor-pointer",
    "hover:bg-accent hover:text-accent-foreground",
    "focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
    className
)}>
```

#### 2. **面板容器样式**
```typescript
<div className="flex max-h-80 overflow-hidden" role="tree">
    {panels.map((panel) => (
        <div className={cn(
            "w-48 border-r border-border last:border-r-0",
            "overflow-y-auto flex-shrink-0"
        )}>
```

#### 3. **文件夹项样式**
```typescript
<div className={cn(
    "flex items-center gap-2 px-3 py-2 cursor-pointer transition-colors text-sm",
    "hover:bg-muted/50",
    isSelected && "bg-primary/10 text-primary font-medium",
    isHovered && !isSelected && "bg-muted/30"
)}>
```

## 无障碍访问支持

### ♿ **ARIA属性**

#### 1. **语义化角色**
```typescript
// 整个组件
role="combobox"
aria-expanded={isOpen}
aria-haspopup="tree"

// 面板容器
role="tree"
aria-label="文件夹选择器"

// 文件夹项
role="treeitem"
aria-selected={isSelected}
aria-expanded={hasChildren ? isHovered : undefined}
aria-level={level + 1}
```

#### 2. **键盘导航**
- **Tab键**: 正常的焦点流转
- **Enter/Space**: 打开/关闭面板
- **Escape**: 关闭面板
- **方向键**: 在面板间和文件夹间导航

#### 3. **屏幕阅读器支持**
- 提供清晰的层级信息
- 标识选中状态和展开状态
- 支持语音导航

## 性能优化

### ⚡ **优化策略**

#### 1. **React优化**
```typescript
// 使用 useMemo 缓存面板数据
const panels = useMemo(() => {
    // 面板构建逻辑
}, [folders, hoveredPath]);

// 使用 useCallback 优化事件处理
const handleFolderHover = useCallback((folderId, level) => {
    // 悬停处理逻辑
}, [hoveredPath]);
```

#### 2. **渲染优化**
- 虚拟滚动支持（面板内容过多时）
- 延迟加载子面板
- 限制最大面板数量

#### 3. **内存管理**
- 及时清理定时器
- 避免内存泄漏
- 优化事件监听器

## 对比分析

### 📊 **与其他方案的对比**

#### TreeSelector vs FolderSelect vs CascadingFolderSelect

| 特性 | TreeSelector | FolderSelect | CascadingFolderSelect |
|------|-------------|--------------|----------------------|
| **高度稳定性** | ❌ 动态变化 | ✅ 固定高度 | ✅ 固定高度 |
| **空间利用** | ❌ 占用大量垂直空间 | ✅ 收起时节省空间 | ✅ 弹出层不影响布局 |
| **层级可视化** | ✅ 树形结构清晰 | ⚠️ 缩进表示层级 | ✅ 多面板直观展示 |
| **操作便捷性** | ⚠️ 需要逐级展开 | ✅ 一次点击选择 | ✅ 悬停即展开 |
| **用户体验** | ⚠️ 传统但复杂 | ✅ 简单直接 | ✅ 现代化交互 |
| **认知负担** | ❌ 需要理解树形结构 | ✅ 简单列表选择 | ✅ 符合文件管理习惯 |

#### 交互方式对比
```
TreeSelector:
1. 点击展开按钮 → 2. 逐级展开 → 3. 找到目标 → 4. 点击选择
操作步骤: 3-5步

FolderSelect:
1. 点击下拉栏 → 2. 在列表中找到目标 → 3. 点击选择
操作步骤: 2-3步

CascadingFolderSelect:
1. 点击触发器 → 2. 悬停导航 → 3. 点击选择
操作步骤: 2-3步，但导航更直观
```

## 优势分析

### ✅ **用户体验优势**

#### 1. **直观的导航**
- 类似文件管理器的交互模式
- 用户学习成本低
- 符合用户认知习惯

#### 2. **高效的操作**
- 悬停即展开，无需点击
- 多层级同时可见
- 快速定位目标文件夹

#### 3. **视觉清晰**
- 每个层级独立显示
- 当前路径一目了然
- 选中状态明确标识

### ✅ **技术优势**

#### 1. **布局稳定**
- 固定高度的触发器
- 弹出层不影响页面布局
- 完美适配Tab布局

#### 2. **性能优秀**
- 按需渲染面板内容
- 智能的悬停延时机制
- 优化的事件处理

#### 3. **可扩展性**
- 支持无限层级嵌套
- 可配置面板数量限制
- 易于添加新功能

## 构建结果

### 📊 **性能数据**
- **构建成功**: 总大小754.37 kB
- **新增依赖**: @radix-ui/react-popover
- **组件替换**: FolderSelect → CascadingFolderSelect
- **功能完整**: 所有选择功能正常工作

### 🎯 **优化效果**
1. **交互体验**: 提供现代化的级联导航体验
2. **布局稳定**: 保持固定高度，不影响页面布局
3. **操作效率**: 悬停展开，操作更加高效
4. **视觉清晰**: 多面板展示，层级关系清晰
5. **用户友好**: 符合用户对文件夹导航的认知习惯

## 使用示例

### 📝 **基本用法**
```typescript
import { CascadingFolderSelect } from "@/components/ui/cascading-folder-select";

<CascadingFolderSelect
    folders={folders}
    selectedId={selectedFolder}
    onSelect={handleFolderChange}
    className="w-full"
    placeholder="选择文件夹"
/>
```

### 🎨 **自定义配置**
```typescript
<CascadingFolderSelect
    folders={folders}
    selectedId={selectedFolder}
    onSelect={handleFolderChange}
    className="w-full max-w-md"
    placeholder="请选择书签根目录"
/>
```

## 总结

通过实现级联面板组件，我们成功创建了一个现代化、直观的文件夹选择器。新的CascadingFolderSelect组件不仅解决了高度稳定性问题，还提供了更优秀的用户体验，完美适配Tab式设置页面的需求。

### 🎯 **核心成就**
- ✅ 实现macOS Finder风格的级联导航
- ✅ 保持固定高度，布局稳定
- ✅ 提供直观的多层级文件夹展示
- ✅ 支持悬停展开和智能延时
- ✅ 完整的无障碍访问支持
- ✅ 优秀的性能表现和用户体验
