# AI书签管家 - 配置同步功能规划

## 📋 功能概述

利用Chrome浏览器的账户数据同步功能，实现同一Google账户下不同设备间的配置自动同步。用户在一台电脑上修改的配置会自动同步到其他登录同一账户的设备上。

---

## 🎯 核心目标

1. **跨设备同步**：配置在多台设备间自动同步
2. **无缝体验**：用户无需手动操作，自动同步
3. **冲突处理**：处理同时修改导致的冲突
4. **向后兼容**：不破坏现有功能

---

## 🏗️ 架构设计

### 1. 存储策略

#### 同步配置项（使用 `browser.storage.sync`）
- **AI配置**：apiUrl, apiKey, modelId
- **主题设置**：theme, accentColor
- **语言设置**：locale
- **自定义Prompt**：customPrompt, useCustomPrompt
- **同步元数据**：lastSyncTime, syncVersion, deviceId

#### 本地配置项（保留 `browser.storage.local`）
- **书签根目录**：bookmarkRootId（设备特定）
- **临时数据**：缓存、草稿等
- **同步状态**：syncStatus, lastError, pendingChanges

### 2. 同步流程

```
用户修改配置
    ↓
本地保存到 storage.local
    ↓
触发同步事件
    ↓
检查冲突
    ↓
上传到 storage.sync
    ↓
其他设备接收变更
    ↓
应用配置更新
```

### 3. 冲突解决策略

**优先级**：最后修改时间 > 版本号 > 设备ID

```typescript
interface SyncMetadata {
  lastModified: number;      // 时间戳
  version: number;           // 版本号
  deviceId: string;          // 设备标识
  source: 'local' | 'sync';  // 来源
}
```

---

## 📦 实现方案

### 1. 新建模块：`lib/configSyncManager.ts`

**职责**：
- 管理同步状态
- 处理冲突解决
- 协调 local 和 sync 存储

**核心接口**：
```typescript
interface ConfigSyncManager {
  // 初始化同步
  initialize(): Promise<void>;
  
  // 保存配置（自动同步）
  saveConfig(key: string, value: any): Promise<void>;
  
  // 获取配置
  getConfig(key: string): Promise<any>;
  
  // 手动同步
  manualSync(): Promise<SyncResult>;
  
  // 监听同步事件
  onSyncChange(callback: (changes: SyncChanges) => void): void;
  
  // 获取同步状态
  getSyncStatus(): Promise<SyncStatus>;
}
```

### 2. 修改现有模块

#### `lib/aiConfigUtils.ts`
- 改用 `configSyncManager.saveConfig()` 替代 `browser.storage.local.set()`
- 改用 `configSyncManager.getConfig()` 替代 `browser.storage.local.get()`

#### `lib/accentColorUtils.ts`
- 同上

#### `lib/aiPromptUtils.ts`
- 同上

#### `components/theme-provider.tsx`
- 同上

### 3. 新增UI组件：`components/settings/sync-status-settings.tsx`

**功能**：
- 显示同步状态（已同步/同步中/失败）
- 显示最后同步时间
- 手动同步按钮
- 同步历史日志

### 4. 更新Manifest权限

```json
{
  "permissions": [
    "storage",
    "tabs",
    "contextMenus",
    "bookmarks"
  ]
}
```

> 注：`storage` 权限已包含 `sync` 和 `local`

---

## 🔄 同步流程详解

### 初始化阶段
1. 检测是否首次安装
2. 从 `storage.sync` 读取已有配置
3. 如果存在，应用到本地
4. 如果不存在，将本地配置上传到 `storage.sync`

### 运行时同步
1. 用户修改配置 → 保存到 `storage.local`
2. 触发 `onChanged` 事件
3. 检查 `storage.sync` 中是否有更新
4. 比较时间戳和版本号
5. 解决冲突（如有）
6. 更新 `storage.sync`

### 跨设备同步
1. Chrome 检测到 `storage.sync` 变更
2. 触发 `onChanged` 事件
3. 应用新配置到本地
4. 更新UI

---

## ⚙️ 技术细节

### 存储限制
- `storage.sync`：每个扩展 100KB
- `storage.local`：每个扩展 10MB

### 同步延迟
- 通常 1-2 秒
- 网络不稳定时可能延迟

### 设备识别
```typescript
const getDeviceId = async (): Promise<string> => {
  let deviceId = await browser.storage.local.get('deviceId');
  if (!deviceId) {
    deviceId = generateUUID();
    await browser.storage.local.set({ deviceId });
  }
  return deviceId;
};
```

---

## 🧪 测试计划

### 单元测试
- 冲突解决逻辑
- 元数据管理
- 状态转换

### 集成测试
- 本地修改 → 同步
- 远程修改 → 应用
- 冲突场景

### 手动测试
- 两台设备同时修改
- 网络中断恢复
- 扩展卸载重装

---

## 📝 实现步骤

1. ✅ 规划与设计（当前）
2. 创建 `configSyncManager.ts` 模块
3. 集成 Chrome Storage Sync API
4. 修改现有配置工具函数
5. 添加同步状态UI
6. 编写测试用例
7. 文档更新

---

## 🚀 后续优化

- [ ] 配置备份与恢复
- [ ] 选择性同步（用户可选择哪些配置同步）
- [ ] 同步历史查看
- [ ] 设备管理（查看/删除其他设备的配置）
- [ ] 加密敏感信息（如API Key）


