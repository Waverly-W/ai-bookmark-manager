# é…ç½®åŒæ­¥åŠŸèƒ½ - å®ç°æŒ‡å—

## ğŸ“‚ æ–‡ä»¶ç»“æ„

```
lib/
â”œâ”€â”€ configSyncManager.ts          # æ ¸å¿ƒåŒæ­¥ç®¡ç†å™¨
â”œâ”€â”€ aiConfigUtils.ts              # ä¿®æ”¹ï¼šé›†æˆåŒæ­¥
â”œâ”€â”€ accentColorUtils.ts            # ä¿®æ”¹ï¼šé›†æˆåŒæ­¥
â”œâ”€â”€ aiPromptUtils.ts               # ä¿®æ”¹ï¼šé›†æˆåŒæ­¥
â””â”€â”€ __tests__/
    â””â”€â”€ configSyncManager.test.ts  # æµ‹è¯•

components/
â”œâ”€â”€ settings/
â”‚   â”œâ”€â”€ sync-status-settings.tsx   # æ–°å¢ï¼šåŒæ­¥çŠ¶æ€UI
â”‚   â”œâ”€â”€ ai-config-settings.tsx     # ä¿®æ”¹ï¼šä½¿ç”¨åŒæ­¥ç®¡ç†å™¨
â”‚   â”œâ”€â”€ theme-settings.tsx         # ä¿®æ”¹ï¼šä½¿ç”¨åŒæ­¥ç®¡ç†å™¨
â”‚   â””â”€â”€ accent-color-settings.tsx  # ä¿®æ”¹ï¼šä½¿ç”¨åŒæ­¥ç®¡ç†å™¨

components/
â”œâ”€â”€ theme-provider.tsx             # ä¿®æ”¹ï¼šä½¿ç”¨åŒæ­¥ç®¡ç†å™¨
```

## ğŸ”§ æ ¸å¿ƒå®ç°

### 1. ConfigSyncManager ç±»è®¾è®¡

```typescript
// lib/configSyncManager.ts

interface SyncMetadata {
  lastModified: number;
  version: number;
  deviceId: string;
}

interface SyncStatus {
  isSyncing: boolean;
  lastSyncTime: number | null;
  lastError: string | null;
  pendingChanges: number;
}

interface SyncChanges {
  [key: string]: {
    oldValue: any;
    newValue: any;
    source: 'local' | 'sync';
  };
}

class ConfigSyncManager {
  private static instance: ConfigSyncManager;
  private syncStatus: SyncStatus;
  private changeListeners: Set<(changes: SyncChanges) => void>;
  private deviceId: string;
  
  // éœ€è¦åŒæ­¥çš„é…ç½®é”®
  private syncableKeys = [
    'aiConfig',
    'theme',
    'accentColor',
    'locale',
    'aiCustomPrompt',
    'aiUseCustomPrompt'
  ];

  private constructor() {
    this.syncStatus = {
      isSyncing: false,
      lastSyncTime: null,
      lastError: null,
      pendingChanges: 0
    };
    this.changeListeners = new Set();
  }

  static getInstance(): ConfigSyncManager {
    if (!ConfigSyncManager.instance) {
      ConfigSyncManager.instance = new ConfigSyncManager();
    }
    return ConfigSyncManager.instance;
  }

  async initialize(): Promise<void> {
    // 1. è·å–æˆ–ç”Ÿæˆè®¾å¤‡ID
    this.deviceId = await this.getOrCreateDeviceId();
    
    // 2. æ£€æŸ¥æ˜¯å¦é¦–æ¬¡åŒæ­¥
    const isFirstSync = await this.isFirstSync();
    
    if (isFirstSync) {
      // å°†æœ¬åœ°é…ç½®ä¸Šä¼ åˆ° sync
      await this.uploadLocalConfigToSync();
    } else {
      // ä» sync æ‹‰å–é…ç½®
      await this.pullConfigFromSync();
    }
    
    // 3. ç›‘å¬ storage å˜æ›´
    this.setupStorageListener();
  }

  async saveConfig(key: string, value: any): Promise<void> {
    if (!this.syncableKeys.includes(key)) {
      // éåŒæ­¥é…ç½®ï¼Œåªä¿å­˜åˆ° local
      await browser.storage.local.set({ [key]: value });
      return;
    }

    // 1. ä¿å­˜åˆ° local
    await browser.storage.local.set({ [key]: value });
    
    // 2. å‡†å¤‡åŒæ­¥å…ƒæ•°æ®
    const metadata: SyncMetadata = {
      lastModified: Date.now(),
      version: await this.getNextVersion(key),
      deviceId: this.deviceId
    };
    
    // 3. ä¸Šä¼ åˆ° sync
    const syncKey = `${key}__sync`;
    const syncValue = `${key}__metadata`;
    
    await browser.storage.sync.set({
      [syncKey]: value,
      [syncValue]: metadata
    });
    
    // 4. æ›´æ–°åŒæ­¥çŠ¶æ€
    this.syncStatus.lastSyncTime = Date.now();
    this.syncStatus.lastError = null;
  }

  async getConfig(key: string): Promise<any> {
    // ä¼˜å…ˆä» local è¯»å–
    const localResult = await browser.storage.local.get(key);
    return localResult[key];
  }

  async manualSync(): Promise<void> {
    this.syncStatus.isSyncing = true;
    
    try {
      // 1. ä» sync æ‹‰å–æ‰€æœ‰é…ç½®
      const syncData = await browser.storage.sync.get(null);
      
      // 2. æ¯”è¾ƒå¹¶è§£å†³å†²çª
      const conflicts = await this.detectConflicts(syncData);
      const resolved = await this.resolveConflicts(conflicts);
      
      // 3. åº”ç”¨æ›´æ–°
      await this.applyChanges(resolved);
      
      this.syncStatus.lastSyncTime = Date.now();
      this.syncStatus.lastError = null;
    } catch (error) {
      this.syncStatus.lastError = error instanceof Error ? error.message : 'Unknown error';
      throw error;
    } finally {
      this.syncStatus.isSyncing = false;
    }
  }

  getSyncStatus(): SyncStatus {
    return { ...this.syncStatus };
  }

  onSyncChange(callback: (changes: SyncChanges) => void): void {
    this.changeListeners.add(callback);
  }

  // ç§æœ‰æ–¹æ³•
  private async getOrCreateDeviceId(): Promise<string> {
    const result = await browser.storage.local.get('deviceId');
    if (result.deviceId) {
      return result.deviceId;
    }
    
    const deviceId = this.generateUUID();
    await browser.storage.local.set({ deviceId });
    return deviceId;
  }

  private async isFirstSync(): Promise<boolean> {
    const result = await browser.storage.local.get('syncInitialized');
    return !result.syncInitialized;
  }

  private async uploadLocalConfigToSync(): Promise<void> {
    for (const key of this.syncableKeys) {
      const result = await browser.storage.local.get(key);
      if (result[key]) {
        const metadata: SyncMetadata = {
          lastModified: Date.now(),
          version: 1,
          deviceId: this.deviceId
        };
        
        await browser.storage.sync.set({
          [key]: result[key],
          [`${key}__metadata`]: metadata
        });
      }
    }
    
    await browser.storage.local.set({ syncInitialized: true });
  }

  private async pullConfigFromSync(): Promise<void> {
    const syncData = await browser.storage.sync.get(null);
    
    for (const key of this.syncableKeys) {
      if (syncData[key]) {
        await browser.storage.local.set({ [key]: syncData[key] });
      }
    }
  }

  private setupStorageListener(): void {
    browser.storage.onChanged.addListener((changes, areaName) => {
      if (areaName === 'sync') {
        this.handleSyncChanges(changes);
      }
    });
  }

  private async handleSyncChanges(changes: any): Promise<void> {
    const syncChanges: SyncChanges = {};
    
    for (const [key, change] of Object.entries(changes)) {
      if (key.endsWith('__metadata')) continue;
      
      syncChanges[key] = {
        oldValue: change.oldValue,
        newValue: change.newValue,
        source: 'sync'
      };
      
      // åº”ç”¨åˆ° local
      if (change.newValue !== undefined) {
        await browser.storage.local.set({ [key]: change.newValue });
      }
    }
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.changeListeners.forEach(listener => listener(syncChanges));
  }

  private async detectConflicts(syncData: any): Promise<any[]> {
    // æ£€æµ‹æœ¬åœ°å’Œè¿œç¨‹é…ç½®çš„å†²çª
    const conflicts = [];
    
    for (const key of this.syncableKeys) {
      const localResult = await browser.storage.local.get(key);
      const localValue = localResult[key];
      const syncValue = syncData[key];
      
      if (localValue && syncValue && localValue !== syncValue) {
        conflicts.push({
          key,
          localValue,
          syncValue,
          localMetadata: syncData[`${key}__metadata`],
          syncMetadata: syncData[`${key}__metadata`]
        });
      }
    }
    
    return conflicts;
  }

  private async resolveConflicts(conflicts: any[]): Promise<any> {
    const resolved = {};
    
    for (const conflict of conflicts) {
      const winner = this.compareMetadata(
        conflict.localMetadata,
        conflict.syncMetadata
      );
      
      resolved[conflict.key] = winner === 'local' 
        ? conflict.localValue 
        : conflict.syncValue;
    }
    
    return resolved;
  }

  private compareMetadata(local: SyncMetadata, sync: SyncMetadata): 'local' | 'sync' {
    // æ¯”è¾ƒæ—¶é—´æˆ³
    if (local.lastModified > sync.lastModified) return 'local';
    if (sync.lastModified > local.lastModified) return 'sync';
    
    // æ¯”è¾ƒç‰ˆæœ¬å·
    if (local.version > sync.version) return 'local';
    if (sync.version > local.version) return 'sync';
    
    // æ¯”è¾ƒè®¾å¤‡IDï¼ˆå­—å…¸åºï¼‰
    return local.deviceId > sync.deviceId ? 'local' : 'sync';
  }

  private async applyChanges(changes: any): Promise<void> {
    for (const [key, value] of Object.entries(changes)) {
      await browser.storage.local.set({ [key]: value });
    }
  }

  private async getNextVersion(key: string): Promise<number> {
    const result = await browser.storage.local.get(`${key}__version`);
    const currentVersion = result[`${key}__version`] || 0;
    const nextVersion = currentVersion + 1;
    await browser.storage.local.set({ [`${key}__version`]: nextVersion });
    return nextVersion;
  }

  private generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}

export const configSyncManager = ConfigSyncManager.getInstance();
```

## ğŸ”Œ é›†æˆç°æœ‰æ¨¡å—

### ä¿®æ”¹ `lib/aiConfigUtils.ts`

```typescript
// æ›¿æ¢ saveAIConfig
export const saveAIConfig = async (config: AIConfig): Promise<void> => {
  try {
    const configToSave = {
      ...config,
      apiKey: encodeApiKey(config.apiKey)
    };
    
    // ä½¿ç”¨åŒæ­¥ç®¡ç†å™¨
    await configSyncManager.saveConfig(STORAGE_KEYS.AI_CONFIG, configToSave);
  } catch (error) {
    console.error('Failed to save AI config:', error);
    throw new Error('Failed to save AI configuration');
  }
};

// æ›¿æ¢ getAIConfig
export const getAIConfig = async (): Promise<AIConfig> => {
  try {
    const savedConfig = await configSyncManager.getConfig(STORAGE_KEYS.AI_CONFIG);
    
    if (savedConfig) {
      return {
        ...savedConfig,
        apiKey: decodeApiKey(savedConfig.apiKey)
      };
    }
    
    return {
      apiUrl: 'https://api.openai.com/v1',
      apiKey: '',
      modelId: 'gpt-3.5-turbo'
    };
  } catch (error) {
    console.error('Failed to get AI config:', error);
    return {
      apiUrl: 'https://api.openai.com/v1',
      apiKey: '',
      modelId: 'gpt-3.5-turbo'
    };
  }
};
```

## ğŸ“Š UI ç»„ä»¶

### æ–°å¢ `components/settings/sync-status-settings.tsx`

```typescript
export function SyncStatusSettings() {
  const { t } = useTranslation();
  const [syncStatus, setSyncStatus] = useState<SyncStatus | null>(null);
  const [syncing, setSyncing] = useState(false);

  useEffect(() => {
    const updateStatus = async () => {
      const status = await configSyncManager.getSyncStatus();
      setSyncStatus(status);
    };

    updateStatus();
    const interval = setInterval(updateStatus, 1000);
    return () => clearInterval(interval);
  }, []);

  const handleManualSync = async () => {
    setSyncing(true);
    try {
      await configSyncManager.manualSync();
      // æ›´æ–°çŠ¶æ€
    } catch (error) {
      console.error('Sync failed:', error);
    } finally {
      setSyncing(false);
    }
  };

  return (
    <div className="space-y-3">
      <div className="space-y-1">
        <h4 className="font-medium text-sm">{t('syncStatus')}</h4>
        <p className="text-xs text-muted-foreground">{t('syncStatusDescription')}</p>
      </div>
      
      {/* åŒæ­¥çŠ¶æ€æ˜¾ç¤º */}
      <div className="flex items-center justify-between">
        <span className="text-sm">{t('lastSyncTime')}:</span>
        <span className="text-sm text-muted-foreground">
          {syncStatus?.lastSyncTime 
            ? new Date(syncStatus.lastSyncTime).toLocaleString()
            : t('never')}
        </span>
      </div>
      
      {/* æ‰‹åŠ¨åŒæ­¥æŒ‰é’® */}
      <Button 
        onClick={handleManualSync} 
        disabled={syncing || syncStatus?.isSyncing}
      >
        {syncing ? t('syncing') : t('manualSync')}
      </Button>
      
      {/* é”™è¯¯æç¤º */}
      {syncStatus?.lastError && (
        <div className="text-sm text-red-500">
          {t('syncError')}: {syncStatus.lastError}
        </div>
      )}
    </div>
  );
}
```


