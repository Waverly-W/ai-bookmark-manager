# 配置同步功能 - 实现指南

## 📂 文件结构

```
lib/
├── configSyncManager.ts          # 核心同步管理器
├── aiConfigUtils.ts              # 修改：集成同步
├── accentColorUtils.ts            # 修改：集成同步
├── aiPromptUtils.ts               # 修改：集成同步
└── __tests__/
    └── configSyncManager.test.ts  # 测试

components/
├── settings/
│   ├── sync-status-settings.tsx   # 新增：同步状态UI
│   ├── ai-config-settings.tsx     # 修改：使用同步管理器
│   ├── theme-settings.tsx         # 修改：使用同步管理器
│   └── accent-color-settings.tsx  # 修改：使用同步管理器

components/
├── theme-provider.tsx             # 修改：使用同步管理器
```

## 🔧 核心实现

### 1. ConfigSyncManager 类设计

```typescript
// lib/configSyncManager.ts

interface SyncMetadata {
  lastModified: number;
  version: number;
  deviceId: string;
}

interface SyncStatus {
  isSyncing: boolean;
  lastSyncTime: number | null;
  lastError: string | null;
  pendingChanges: number;
}

interface SyncChanges {
  [key: string]: {
    oldValue: any;
    newValue: any;
    source: 'local' | 'sync';
  };
}

class ConfigSyncManager {
  private static instance: ConfigSyncManager;
  private syncStatus: SyncStatus;
  private changeListeners: Set<(changes: SyncChanges) => void>;
  private deviceId: string;
  
  // 需要同步的配置键
  private syncableKeys = [
    'aiConfig',
    'theme',
    'accentColor',
    'locale',
    'aiCustomPrompt',
    'aiUseCustomPrompt'
  ];

  private constructor() {
    this.syncStatus = {
      isSyncing: false,
      lastSyncTime: null,
      lastError: null,
      pendingChanges: 0
    };
    this.changeListeners = new Set();
  }

  static getInstance(): ConfigSyncManager {
    if (!ConfigSyncManager.instance) {
      ConfigSyncManager.instance = new ConfigSyncManager();
    }
    return ConfigSyncManager.instance;
  }

  async initialize(): Promise<void> {
    // 1. 获取或生成设备ID
    this.deviceId = await this.getOrCreateDeviceId();
    
    // 2. 检查是否首次同步
    const isFirstSync = await this.isFirstSync();
    
    if (isFirstSync) {
      // 将本地配置上传到 sync
      await this.uploadLocalConfigToSync();
    } else {
      // 从 sync 拉取配置
      await this.pullConfigFromSync();
    }
    
    // 3. 监听 storage 变更
    this.setupStorageListener();
  }

  async saveConfig(key: string, value: any): Promise<void> {
    if (!this.syncableKeys.includes(key)) {
      // 非同步配置，只保存到 local
      await browser.storage.local.set({ [key]: value });
      return;
    }

    // 1. 保存到 local
    await browser.storage.local.set({ [key]: value });
    
    // 2. 准备同步元数据
    const metadata: SyncMetadata = {
      lastModified: Date.now(),
      version: await this.getNextVersion(key),
      deviceId: this.deviceId
    };
    
    // 3. 上传到 sync
    const syncKey = `${key}__sync`;
    const syncValue = `${key}__metadata`;
    
    await browser.storage.sync.set({
      [syncKey]: value,
      [syncValue]: metadata
    });
    
    // 4. 更新同步状态
    this.syncStatus.lastSyncTime = Date.now();
    this.syncStatus.lastError = null;
  }

  async getConfig(key: string): Promise<any> {
    // 优先从 local 读取
    const localResult = await browser.storage.local.get(key);
    return localResult[key];
  }

  async manualSync(): Promise<void> {
    this.syncStatus.isSyncing = true;
    
    try {
      // 1. 从 sync 拉取所有配置
      const syncData = await browser.storage.sync.get(null);
      
      // 2. 比较并解决冲突
      const conflicts = await this.detectConflicts(syncData);
      const resolved = await this.resolveConflicts(conflicts);
      
      // 3. 应用更新
      await this.applyChanges(resolved);
      
      this.syncStatus.lastSyncTime = Date.now();
      this.syncStatus.lastError = null;
    } catch (error) {
      this.syncStatus.lastError = error instanceof Error ? error.message : 'Unknown error';
      throw error;
    } finally {
      this.syncStatus.isSyncing = false;
    }
  }

  getSyncStatus(): SyncStatus {
    return { ...this.syncStatus };
  }

  onSyncChange(callback: (changes: SyncChanges) => void): void {
    this.changeListeners.add(callback);
  }

  // 私有方法
  private async getOrCreateDeviceId(): Promise<string> {
    const result = await browser.storage.local.get('deviceId');
    if (result.deviceId) {
      return result.deviceId;
    }
    
    const deviceId = this.generateUUID();
    await browser.storage.local.set({ deviceId });
    return deviceId;
  }

  private async isFirstSync(): Promise<boolean> {
    const result = await browser.storage.local.get('syncInitialized');
    return !result.syncInitialized;
  }

  private async uploadLocalConfigToSync(): Promise<void> {
    for (const key of this.syncableKeys) {
      const result = await browser.storage.local.get(key);
      if (result[key]) {
        const metadata: SyncMetadata = {
          lastModified: Date.now(),
          version: 1,
          deviceId: this.deviceId
        };
        
        await browser.storage.sync.set({
          [key]: result[key],
          [`${key}__metadata`]: metadata
        });
      }
    }
    
    await browser.storage.local.set({ syncInitialized: true });
  }

  private async pullConfigFromSync(): Promise<void> {
    const syncData = await browser.storage.sync.get(null);
    
    for (const key of this.syncableKeys) {
      if (syncData[key]) {
        await browser.storage.local.set({ [key]: syncData[key] });
      }
    }
  }

  private setupStorageListener(): void {
    browser.storage.onChanged.addListener((changes, areaName) => {
      if (areaName === 'sync') {
        this.handleSyncChanges(changes);
      }
    });
  }

  private async handleSyncChanges(changes: any): Promise<void> {
    const syncChanges: SyncChanges = {};
    
    for (const [key, change] of Object.entries(changes)) {
      if (key.endsWith('__metadata')) continue;
      
      syncChanges[key] = {
        oldValue: change.oldValue,
        newValue: change.newValue,
        source: 'sync'
      };
      
      // 应用到 local
      if (change.newValue !== undefined) {
        await browser.storage.local.set({ [key]: change.newValue });
      }
    }
    
    // 通知监听器
    this.changeListeners.forEach(listener => listener(syncChanges));
  }

  private async detectConflicts(syncData: any): Promise<any[]> {
    // 检测本地和远程配置的冲突
    const conflicts = [];
    
    for (const key of this.syncableKeys) {
      const localResult = await browser.storage.local.get(key);
      const localValue = localResult[key];
      const syncValue = syncData[key];
      
      if (localValue && syncValue && localValue !== syncValue) {
        conflicts.push({
          key,
          localValue,
          syncValue,
          localMetadata: syncData[`${key}__metadata`],
          syncMetadata: syncData[`${key}__metadata`]
        });
      }
    }
    
    return conflicts;
  }

  private async resolveConflicts(conflicts: any[]): Promise<any> {
    const resolved = {};
    
    for (const conflict of conflicts) {
      const winner = this.compareMetadata(
        conflict.localMetadata,
        conflict.syncMetadata
      );
      
      resolved[conflict.key] = winner === 'local' 
        ? conflict.localValue 
        : conflict.syncValue;
    }
    
    return resolved;
  }

  private compareMetadata(local: SyncMetadata, sync: SyncMetadata): 'local' | 'sync' {
    // 比较时间戳
    if (local.lastModified > sync.lastModified) return 'local';
    if (sync.lastModified > local.lastModified) return 'sync';
    
    // 比较版本号
    if (local.version > sync.version) return 'local';
    if (sync.version > local.version) return 'sync';
    
    // 比较设备ID（字典序）
    return local.deviceId > sync.deviceId ? 'local' : 'sync';
  }

  private async applyChanges(changes: any): Promise<void> {
    for (const [key, value] of Object.entries(changes)) {
      await browser.storage.local.set({ [key]: value });
    }
  }

  private async getNextVersion(key: string): Promise<number> {
    const result = await browser.storage.local.get(`${key}__version`);
    const currentVersion = result[`${key}__version`] || 0;
    const nextVersion = currentVersion + 1;
    await browser.storage.local.set({ [`${key}__version`]: nextVersion });
    return nextVersion;
  }

  private generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}

export const configSyncManager = ConfigSyncManager.getInstance();
```

## 🔌 集成现有模块

### 修改 `lib/aiConfigUtils.ts`

```typescript
// 替换 saveAIConfig
export const saveAIConfig = async (config: AIConfig): Promise<void> => {
  try {
    const configToSave = {
      ...config,
      apiKey: encodeApiKey(config.apiKey)
    };
    
    // 使用同步管理器
    await configSyncManager.saveConfig(STORAGE_KEYS.AI_CONFIG, configToSave);
  } catch (error) {
    console.error('Failed to save AI config:', error);
    throw new Error('Failed to save AI configuration');
  }
};

// 替换 getAIConfig
export const getAIConfig = async (): Promise<AIConfig> => {
  try {
    const savedConfig = await configSyncManager.getConfig(STORAGE_KEYS.AI_CONFIG);
    
    if (savedConfig) {
      return {
        ...savedConfig,
        apiKey: decodeApiKey(savedConfig.apiKey)
      };
    }
    
    return {
      apiUrl: 'https://api.openai.com/v1',
      apiKey: '',
      modelId: 'gpt-3.5-turbo'
    };
  } catch (error) {
    console.error('Failed to get AI config:', error);
    return {
      apiUrl: 'https://api.openai.com/v1',
      apiKey: '',
      modelId: 'gpt-3.5-turbo'
    };
  }
};
```

## 📊 UI 组件

### 新增 `components/settings/sync-status-settings.tsx`

```typescript
export function SyncStatusSettings() {
  const { t } = useTranslation();
  const [syncStatus, setSyncStatus] = useState<SyncStatus | null>(null);
  const [syncing, setSyncing] = useState(false);

  useEffect(() => {
    const updateStatus = async () => {
      const status = await configSyncManager.getSyncStatus();
      setSyncStatus(status);
    };

    updateStatus();
    const interval = setInterval(updateStatus, 1000);
    return () => clearInterval(interval);
  }, []);

  const handleManualSync = async () => {
    setSyncing(true);
    try {
      await configSyncManager.manualSync();
      // 更新状态
    } catch (error) {
      console.error('Sync failed:', error);
    } finally {
      setSyncing(false);
    }
  };

  return (
    <div className="space-y-3">
      <div className="space-y-1">
        <h4 className="font-medium text-sm">{t('syncStatus')}</h4>
        <p className="text-xs text-muted-foreground">{t('syncStatusDescription')}</p>
      </div>
      
      {/* 同步状态显示 */}
      <div className="flex items-center justify-between">
        <span className="text-sm">{t('lastSyncTime')}:</span>
        <span className="text-sm text-muted-foreground">
          {syncStatus?.lastSyncTime 
            ? new Date(syncStatus.lastSyncTime).toLocaleString()
            : t('never')}
        </span>
      </div>
      
      {/* 手动同步按钮 */}
      <Button 
        onClick={handleManualSync} 
        disabled={syncing || syncStatus?.isSyncing}
      >
        {syncing ? t('syncing') : t('manualSync')}
      </Button>
      
      {/* 错误提示 */}
      {syncStatus?.lastError && (
        <div className="text-sm text-red-500">
          {t('syncError')}: {syncStatus.lastError}
        </div>
      )}
    </div>
  );
}
```


